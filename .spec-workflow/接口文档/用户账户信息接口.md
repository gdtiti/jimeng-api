# 用户账户信息接口文档

## 接口概述

**接口功能**: 获取用户账户信息，验证token有效性，检查用户权限状态

**请求方法**: POST
**接口路径**: `/passport/account/info/v2`
**支持区域**: 即梦中国、即梦国际
**使用场景**: token验证、用户身份检查、权限验证

## 请求参数

### URL参数 (Query Parameters)

#### 通用参数

| 参数名 | 类型 | 必需 | 默认值 | 说明 |
|--------|------|------|--------|------|
| aid | string | 是 | - | 应用ID |
| device_platform | string | 是 | "web" | 设备平台 |
| region | string | 是 | - | 区域: "cn" 或 "US" |
| webId | string | 是 | - | Web ID |
| da_version | string | 是 | "3.3.2" | DA版本号 |
| web_version | string | 是 | "7.5.0" | Web版本号 |
| aigc_features | string | 是 | "app_lip_sync" | AIGC功能标识 |
| web_component_open_flag | number | 是 | 1 | Web组件开启标志 |

#### 特定参数

| 参数名 | 类型 | 必需 | 说明 |
|--------|------|------|------|
| account_sdk_source | string | 是 | 固定值: "web" |

### 请求体

此接口通常不需要请求体，所有参数通过URL参数传递。

## 请求示例

### 基础用户信息查询

```javascript
async function getUserAccountInfo(refreshToken) {
  const response = await request("POST", "/passport/account/info/v2", refreshToken, {
    params: {
      account_sdk_source: "web",
    },
    headers: {
      Referer: "https://jimeng.jianying.com/ai-tool/image/generate",
    }
  });

  return response;
}
```

### 国际版用户信息查询

```javascript
async function getUserAccountInfoUS(refreshToken) {
  const usToken = `us-${refreshToken}`;

  const response = await request("POST", "/passport/account/info/v2", usToken, {
    params: {
      account_sdk_source: "web",
    },
    headers: {
      Referer: "https://commerce.us.capcut.com/",
    }
  });

  return response;
}
```

### Token有效性检查

```javascript
async function getTokenLiveStatus(refreshToken) {
  try {
    const result = await request("POST", "/passport/account/info/v2", refreshToken, {
      params: {
        account_sdk_source: "web",
      },
    });

    const { user_id } = result;
    return !!user_id;
  } catch (err) {
    return false;
  }
}
```

## 响应结构

### 成功响应 (200)

```json
{
  "ret": "0",
  "errmsg": "success",
  "data": {
    "user_id": "1234567890",
    "user_info": {
      "nickname": "用户昵称",
      "avatar_url": "https://example.com/avatar.jpg",
      "gender": 1,
      "birthday": "1990-01-01",
      "region": "cn",
      "language": "zh-CN",
      "create_time": 1640995200000,
      "last_login_time": 1640995200000,
      "is_verified": true,
      "verification_type": "phone"
    },
    "account_status": {
      "status": "active",
      "is_vip": false,
      "vip_expire_time": 0,
      "vip_level": 0,
      "is_banned": false,
      "ban_reason": "",
      "ban_expire_time": 0
    },
    "permission_info": {
      "can_generate_image": true,
      "can_generate_video": true,
      "daily_limit": 100,
      "used_today": 10,
      "level_permissions": {
        "max_resolution": "4k",
        "max_video_duration": 60,
        "commercial_use": false
      }
    },
    "device_info": {
      "device_id": "device_id_string",
      "platform": "web",
      "version": "7.5.0",
      "last_active_time": 1640995200000
    }
  }
}
```

### 响应字段说明

#### data 对象

| 字段名 | 类型 | 说明 |
|--------|------|------|
| user_id | string | 用户唯一标识 |
| user_info | object | 用户基本信息 |
| account_status | object | 账户状态信息 |
| permission_info | object | 权限信息 |
| device_info | object | 设备信息 |

#### user_info 对象

| 字段名 | 类型 | 说明 |
|--------|------|------|
| nickname | string | 用户昵称 |
| avatar_url | string | 头像URL |
| gender | number | 性别: 0-未知, 1-男, 2-女 |
| birthday | string | 生日 |
| region | string | 用户地区 |
| language | string | 语言设置 |
| create_time | number | 账户创建时间戳 |
| last_login_time | number | 最后登录时间戳 |
| is_verified | boolean | 是否已验证 |
| verification_type | string | 验证类型: "phone", "email", "identity" |

#### account_status 对象

| 字段名 | 类型 | 说明 |
|--------|------|------|
| status | string | 账户状态: "active", "inactive", "suspended" |
| is_vip | boolean | 是否为VIP用户 |
| vip_expire_time | number | VIP过期时间戳 |
| vip_level | number | VIP等级 |
| is_banned | boolean | 是否被封禁 |
| ban_reason | string | 封禁原因 |
| ban_expire_time | number | 封禁过期时间戳 |

#### permission_info 对象

| 字段名 | 类型 | 说明 |
|--------|------|------|
| can_generate_image | boolean | 是否可以生成图片 |
| can_generate_video | boolean | 是否可以生成视频 |
| daily_limit | number | 每日生成限制 |
| used_today | number | 今日已使用次数 |
| level_permissions | object | 等级权限详情 |

#### level_permissions 对象

| 字段名 | 类型 | 说明 |
|--------|------|------|
| max_resolution | string | 最大分辨率: "1k", "2k", "4k" |
| max_video_duration | number | 最大视频时长(秒) |
| commercial_use | boolean | 是否允许商用 |

#### device_info 对象

| 字段名 | 类型 | 说明 |
|--------|------|------|
| device_id | string | 设备ID |
| platform | string | 平台类型 |
| version | string | 版本号 |
| last_active_time | number | 最后活跃时间戳 |

## 常见错误码

| 错误码 | 说明 | 处理建议 |
|--------|------|----------|
| 0 | 成功 | - |
| 1001 | token无效 | 重新获取token |
| 1002 | token过期 | 刷新token |
| 1003 | 用户不存在 | 检查用户状态 |
| 1004 | 账户被封禁 | 联系客服 |
| 1005 | 权限不足 | 升级账户权限 |
| 1006 | 参数错误 | 检查请求参数 |
| 1007 | 服务异常 | 稍后重试 |

## 使用场景

### 1. Token有效性验证

```javascript
class TokenValidator {
  constructor() {
    this.tokenCache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5分钟缓存
  }

  async validateToken(refreshToken) {
    const cacheKey = refreshToken;
    const cached = this.tokenCache.get(cacheKey);

    // 检查缓存
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.valid;
    }

    try {
      const result = await getUserAccountInfo(refreshToken);
      const valid = !!(result && result.user_id);

      // 更新缓存
      this.tokenCache.set(cacheKey, {
        valid: valid,
        timestamp: Date.now(),
        userInfo: result
      });

      return valid;
    } catch (error) {
      // 更新缓存为无效
      this.tokenCache.set(cacheKey, {
        valid: false,
        timestamp: Date.now(),
        error: error.message
      });

      return false;
    }
  }

  async getTokenUserInfo(refreshToken) {
    const cacheKey = refreshToken;
    const cached = this.tokenCache.get(cacheKey);

    if (cached && cached.userInfo && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.userInfo;
    }

    // 强制刷新
    await this.validateToken(refreshToken);
    const updatedCache = this.tokenCache.get(cacheKey);
    return updatedCache?.userInfo || null;
  }

  clearTokenCache(refreshToken) {
    if (refreshToken) {
      this.tokenCache.delete(refreshToken);
    } else {
      this.tokenCache.clear();
    }
  }
}
```

### 2. 用户权限检查

```javascript
class PermissionChecker {
  constructor(tokenValidator) {
    this.tokenValidator = tokenValidator;
    this.permissionCache = new Map();
  }

  async checkGeneratePermission(refreshToken, type = 'image') {
    try {
      const userInfo = await this.tokenValidator.getTokenUserInfo(refreshToken);

      if (!userInfo) {
        return { allowed: false, reason: 'invalid_token' };
      }

      // 检查账户状态
      if (userInfo.account_status.status !== 'active') {
        return { allowed: false, reason: 'account_inactive' };
      }

      if (userInfo.account_status.is_banned) {
        return { allowed: false, reason: 'account_banned' };
      }

      // 检查具体权限
      const permissionKey = type === 'video' ? 'can_generate_video' : 'can_generate_image';
      const canGenerate = userInfo.permission_info[permissionKey];

      if (!canGenerate) {
        return { allowed: false, reason: 'no_permission' };
      }

      // 检查每日限制
      const { daily_limit, used_today } = userInfo.permission_info;
      if (used_today >= daily_limit) {
        return { allowed: false, reason: 'daily_limit_exceeded' };
      }

      return {
        allowed: true,
        remaining: daily_limit - used_today,
        permissions: userInfo.permission_info
      };

    } catch (error) {
      return { allowed: false, reason: 'error', error: error.message };
    }
  }

  async checkAdvancedFeatures(refreshToken, features = []) {
    const userInfo = await this.tokenValidator.getTokenUserInfo(refreshToken);
    if (!userInfo) {
      return { allowed: false, reason: 'invalid_user' };
    }

    const results = {};
    const levelPermissions = userInfo.permission_info.level_permissions;

    for (const feature of features) {
      switch (feature) {
        case '4k_resolution':
          results[feature] = levelPermissions.max_resolution === '4k';
          break;
        case 'long_video':
          results[feature] = levelPermissions.max_video_duration >= 120;
          break;
        case 'commercial_use':
          results[feature] = levelPermissions.commercial_use;
          break;
        default:
          results[feature] = false;
      }
    }

    return results;
  }
}
```

### 3. 用户信息管理

```javascript
class UserInfoManager {
  constructor() {
    this.userInfoCache = new Map();
    this.updateCallbacks = [];
  }

  async getUserInfo(refreshToken, forceRefresh = false) {
    const cacheKey = refreshToken;
    const cached = this.userInfoCache.get(cacheKey);

    if (!forceRefresh && cached && Date.now() - cached.timestamp < 10 * 60 * 1000) {
      return cached.data;
    }

    try {
      const userInfo = await getUserAccountInfo(refreshToken);

      // 更新缓存
      this.userInfoCache.set(cacheKey, {
        data: userInfo,
        timestamp: Date.now()
      });

      // 通知回调
      this.notifyUpdate(refreshToken, userInfo);

      return userInfo;
    } catch (error) {
      console.error('获取用户信息失败:', error);
      throw error;
    }
  }

  onUpdate(callback) {
    this.updateCallbacks.push(callback);
  }

  notifyUpdate(refreshToken, userInfo) {
    this.updateCallbacks.forEach(callback => {
      try {
        callback(refreshToken, userInfo);
      } catch (error) {
        console.error('用户信息更新回调出错:', error);
      }
    });
  }

  getUserSummary(refreshToken) {
    const cached = this.userInfoCache.get(refreshToken);
    if (!cached) return null;

    const userInfo = cached.data;
    return {
      userId: userInfo.user_id,
      nickname: userInfo.user_info.nickname,
      isVip: userInfo.account_status.is_vip,
      status: userInfo.account_status.status,
      canGenerateImage: userInfo.permission_info.can_generate_image,
      canGenerateVideo: userInfo.permission_info.can_generate_video,
      remainingQuota: userInfo.permission_info.daily_limit - userInfo.permission_info.used_today
    };
  }

  clearUserInfo(refreshToken) {
    if (refreshToken) {
      this.userInfoCache.delete(refreshToken);
    } else {
      this.userInfoCache.clear();
    }
  }
}
```

### 4. 批量用户验证

```javascript
class BatchUserValidator {
  constructor(maxConcurrency = 5) {
    this.maxConcurrency = maxConcurrency;
    this.queue = [];
    this.processing = 0;
    this.results = new Map();
  }

  async validateUsers(refreshTokens) {
    const promises = refreshTokens.map(token => this.addValidationRequest(token));
    const results = await Promise.allSettled(promises);

    const validUsers = [];
    const invalidUsers = [];

    results.forEach((result, index) => {
      const token = refreshTokens[index];
      if (result.status === 'fulfilled' && result.value) {
        validUsers.push({ token, valid: result.value });
      } else {
        invalidUsers.push({ token, valid: false, error: result.reason });
      }
    });

    return { validUsers, invalidUsers };
  }

  async addValidationRequest(refreshToken) {
    if (this.results.has(refreshToken)) {
      return this.results.get(refreshToken);
    }

    return new Promise((resolve, reject) => {
      this.queue.push({
        refreshToken,
        resolve,
        reject,
        timestamp: Date.now()
      });

      this.processQueue();
    });
  }

  async processQueue() {
    if (this.processing >= this.maxConcurrency || this.queue.length === 0) {
      return;
    }

    this.processing++;
    const request = this.queue.shift();

    try {
      const isValid = await getTokenLiveStatus(request.refreshToken);
      this.results.set(request.refreshToken, isValid);
      request.resolve(isValid);
    } catch (error) {
      this.results.set(request.refreshToken, false);
      request.reject(error);
    } finally {
      this.processing--;
      this.processQueue();
    }
  }

  clearCache() {
    this.results.clear();
  }
}
```

## 地区差异

### 即梦中国

- **基础URL**: `https://jimeng.jianying.com`
- **应用ID**: 513695
- **语言**: 中文为主
- **权限规则**: 遵循中国大陆地区规则

### 即梦国际

- **基础URL**: `https://commerce.us.capcut.com`
- **应用ID**: 513641
- **语言**: 英文为主
- **权限规则**: 遵循国际版规则

## 性能优化

### 缓存策略

```javascript
class UserInfoCache {
  constructor() {
    this.cache = new Map();
    this.defaultTTL = 10 * 60 * 1000; // 10分钟默认缓存
    this.cleanupInterval = setInterval(() => this.cleanup(), 60 * 1000); // 每分钟清理
  }

  set(key, value, ttl = this.defaultTTL) {
    this.cache.set(key, {
      value,
      expires: Date.now() + ttl,
      timestamp: Date.now()
    });
  }

  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() > item.expires) {
      this.cache.delete(key);
      return null;
    }

    return item.value;
  }

  has(key) {
    return this.get(key) !== null;
  }

  delete(key) {
    return this.cache.delete(key);
  }

  cleanup() {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now > item.expires) {
        this.cache.delete(key);
      }
    }
  }

  clear() {
    this.cache.clear();
  }

  getStats() {
    const now = Date.now();
    let expired = 0;
    let valid = 0;

    for (const item of this.cache.values()) {
      if (now > item.expires) {
        expired++;
      } else {
        valid++;
      }
    }

    return {
      total: this.cache.size,
      valid,
      expired,
      memoryUsage: process.memoryUsage()
    };
  }
}
```

### 请求优化

```javascript
class OptimizedUserInfoClient {
  constructor() {
    this.cache = new UserInfoCache();
    this.requestQueue = new Map();
    this.requestTimeout = 10000; // 10秒超时
  }

  async getUserInfo(refreshToken, forceRefresh = false) {
    // 检查缓存
    if (!forceRefresh) {
      const cached = this.cache.get(refreshToken);
      if (cached) {
        return cached;
      }
    }

    // 检查是否已有相同的请求在进行
    if (this.requestQueue.has(refreshToken)) {
      return this.requestQueue.get(refreshToken);
    }

    // 创建新请求
    const requestPromise = this.fetchUserInfo(refreshToken);
    this.requestQueue.set(refreshToken, requestPromise);

    try {
      const userInfo = await requestPromise;
      this.cache.set(refreshToken, userInfo);
      return userInfo;
    } finally {
      this.requestQueue.delete(refreshToken);
    }
  }

  async fetchUserInfo(refreshToken) {
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('请求超时')), this.requestTimeout);
    });

    const fetchPromise = getUserAccountInfo(refreshToken);

    return Promise.race([fetchPromise, timeoutPromise]);
  }
}
```

## 监控和日志

### 用户指标监控

```javascript
const userMetrics = {
  totalQueries: 0,
  successfulQueries: 0,
  failedQueries: 0,
  activeUsers: new Set(),
  vipUsers: new Set(),
    regionDistribution: {},
  errorDistribution: {},
  avgResponseTime: 0
};

function recordUserQuery(refreshToken, success, responseTime = 0, userInfo = null) {
  userMetrics.totalQueries++;

  if (success) {
    userMetrics.successfulQueries++;
    userMetrics.activeUsers.add(refreshToken);

    if (userInfo?.account_status?.is_vip) {
      userMetrics.vipUsers.add(refreshToken);
    }

    if (userInfo?.user_info?.region) {
      const region = userInfo.user_info.region;
      userMetrics.regionDistribution[region] = (userMetrics.regionDistribution[region] || 0) + 1;
    }
  } else {
    userMetrics.failedQueries++;
  }

  const totalProcessed = userMetrics.successfulQueries + userMetrics.failedQueries;
  userMetrics.avgResponseTime =
    (userMetrics.avgResponseTime * (totalProcessed - 1) + responseTime) / totalProcessed;
}
```

### 日志记录

```javascript
function logUserQuery(refreshToken, userInfo, responseTime, success) {
  console.log('用户信息查询:', {
    tokenHash: refreshToken.substring(0, 8) + '***',
    userId: userInfo?.user_id,
    nickname: userInfo?.user_info?.nickname,
    isVip: userInfo?.account_status?.is_vip,
    status: userInfo?.account_status?.status,
    canGenerateImage: userInfo?.permission_info?.can_generate_image,
    canGenerateVideo: userInfo?.permission_info?.can_generate_video,
    success: success,
    responseTime: responseTime,
    timestamp: new Date().toISOString()
  });
}
```

## 错误处理

### 智能错误处理

```javascript
class UserErrorHandler {
  constructor() {
    this.errorCounts = new Map();
    this.maxRetries = 3;
    this.backoffMultiplier = 2;
  }

  async handleError(error, refreshToken, operation = 'getUserInfo') {
    const errorKey = `${refreshToken}-${operation}`;
    const currentCount = this.errorCounts.get(errorKey) || 0;

    // 记录错误
    this.errorCounts.set(errorKey, currentCount + 1);

    // 判断错误类型
    if (this.isTokenError(error)) {
      return this.handleTokenError(error, refreshToken);
    } else if (this.isNetworkError(error)) {
      return this.handleNetworkError(error, refreshToken, currentCount);
    } else if (this.isPermissionError(error)) {
      return this.handlePermissionError(error, refreshToken);
    } else {
      return this.handleGenericError(error, refreshToken);
    }
  }

  isTokenError(error) {
    const tokenErrorMessages = ['invalid_token', 'token_expired', 'unauthorized'];
    return tokenErrorMessages.some(msg => error.message.toLowerCase().includes(msg));
  }

  isNetworkError(error) {
    const networkErrorMessages = ['timeout', 'network', 'connection', 'service_unavailable'];
    return networkErrorMessages.some(msg => error.message.toLowerCase().includes(msg));
  }

  isPermissionError(error) {
    const permissionErrorMessages = ['permission_denied', 'access_denied', 'forbidden'];
    return permissionErrorMessages.some(msg => error.message.toLowerCase().includes(msg));
  }

  async handleTokenError(error, refreshToken) {
    console.error('Token错误:', error.message);
    // 清除相关缓存
    this.clearCacheForToken(refreshToken);
    throw new Error('Token无效或已过期，请重新获取');
  }

  async handleNetworkError(error, refreshToken, retryCount) {
    if (retryCount >= this.maxRetries) {
      throw new Error('网络请求失败，已达到最大重试次数');
    }

    const delay = 1000 * Math.pow(this.backoffMultiplier, retryCount);
    console.log(`网络错误，${delay}ms后重试 (第${retryCount + 1}次)`);

    await new Promise(resolve => setTimeout(resolve, delay));

    // 重新尝试请求
    return this.retryOperation(refreshToken);
  }

  async handlePermissionError(error, refreshToken) {
    console.error('权限错误:', error.message);
    throw new Error('权限不足，请检查账户状态');
  }

  handleGenericError(error, refreshToken) {
    console.error('未知错误:', error);
    throw new Error(`操作失败: ${error.message}`);
  }

  clearCacheForToken(refreshToken) {
    // 清除与该token相关的所有缓存
    // 实现具体的缓存清理逻辑
  }

  async retryOperation(refreshToken) {
    // 实现具体的重试逻辑
    return getUserAccountInfo(refreshToken);
  }
}
```

## 安全考虑

1. **令牌保护**: 严格保护refreshToken，避免泄露
2. **数据验证**: 验证返回数据的完整性和合法性
3. **缓存安全**: 合理设置缓存过期时间，避免使用过期数据
4. **频率限制**: 避免过于频繁的查询请求
5. **错误处理**: 妥善处理各种异常，避免信息泄露
6. **HTTPS传输**: 确保所有请求通过HTTPS传输
7. **日志安全**: 避免在日志中记录敏感用户信息
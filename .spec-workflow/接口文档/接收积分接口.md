# 接收积分接口文档

## 接口概述

**接口功能**: 领取每日���分奖励，增加用户可用积分余额

**请求方法**: POST
**接口路径**: `/commerce/v1/benefits/credit_receive`
**支持区域**: 即梦中国、即梦国际
**使用场景**: 积分不足时自动领取每日奖励、用户手动领取奖励

## 请求参数

### URL参数 (Query Parameters)

#### 通用参数

| 参数名 | 类型 | 必需 | 默认值 | 说明 |
|--------|------|------|--------|------|
| aid | string | 是 | - | 应用ID |
| device_platform | string | 是 | "web" | 设备平台 |
| region | string | 是 | - | 区域: "cn" 或 "US" |
| webId | string | 是 | - | Web ID |
| da_version | string | 是 | "3.3.2" | DA版本号 |
| web_version | string | 是 | "7.5.0" | Web版本号 |
| aigc_features | string | 是 | "app_lip_sync" | AIGC功能标识 |
| web_component_open_flag | number | 是 | 1 | Web组件开启标志 |

### 请求体 (Request Body)

```json
{
  "time_zone": "Asia/Shanghai"
}
```

#### 请求体参数说明

| 参数名 | 类型 | 必需 | 说明 |
|--------|------|------|------|
| time_zone | string | 是 | 时区标识，如"Asia/Shanghai" |

#### 常用时区值

| 时区值 | 说明 | 适用地区 |
|--------|------|----------|
| Asia/Shanghai | 中国标准时间 (UTC+8) | 中国大陆 |
| Asia/Tokyo | 日本标准时间 (UTC+9) | 日本 |
| Asia/Seoul | 韩国标准时间 (UTC+9) | 韩国 |
| America/New_York | 美国东部时间 (UTC-5/-4) | 美国东部 |
| America/Los_Angeles | 美国太平洋时间 (UTC-8/-7) | 美国西部 |
| Europe/London | 格林威治时间 (UTC+0/+1) | 英国 |
| Europe/Paris | 中欧时间 (UTC+1/+2) | 法国、德国 |

## 请求头构建

### 必需请求头

```javascript
{
  "Accept": "application/json, text/plain, */*",
  "Accept-Encoding": "gzip, deflate, br, zstd",
  "Accept-language": "zh-CN,zh;q=0.9",
  "Cache-control": "no-cache",
  "Pragma": "no-cache",
  "Priority": "u=1, i",
  "Appvr": "1.0.0",
  "Pf": "7",
  "Sec-Ch-Ua": '"Google Chrome";v="131", "Chromium";v="131", "Not_A Brand";v="24"',
  "Sec-Ch-Ua-Mobile": "?0",
  "Sec-Ch-Ua-Platform": '"Windows"',
  "Sec-Fetch-Dest": "empty",
  "Sec-Fetch-Mode": "cors",
  "Sec-Fetch-Site": "same-origin",
  "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
  "Origin": "https://jimeng.jianying.com",
  "Referer": "https://jimeng.jianying.com/ai-tool/image/generate",
  "Appid": "513695",
  "Cookie": "generated_cookie_string",
  "Device-Time": "device_timestamp",
  "Sign": "generated_signature",
  "Sign-Ver": "1"
}
```

### 地区特定头部

| 字段名 | 即梦中国 | 即梦国际 |
|--------|----------|----------|
| Origin | https://jimeng.jianying.com | https://commerce.us.capcut.com |
| Referer | https://jimeng.jianying.com/ai-tool/image/generate | https://commerce.us.capcut.com/ |
| Appid | 513695 | 513641 |

## 请求示例

### 基础接收积分请求

```javascript
async function receiveCredit(refreshToken) {
  const requestData = {
    time_zone: "Asia/Shanghai"
  };

  const response = await request("POST", "/commerce/v1/benefits/credit_receive", refreshToken, {
    data: requestData,
    headers: {
      Referer: "https://jimeng.jianying.com/ai-tool/image/generate"
    }
  });

  return response;
}
```

### 国际版接收积分请求

```javascript
async function receiveCreditUS(refreshToken) {
  const usToken = `us-${refreshToken}`;
  const requestData = {
    time_zone: "America/New_York"
  };

  const response = await request("POST", "/commerce/v1/benefits/credit_receive", usToken, {
    data: requestData,
    headers: {
      Referer: "https://commerce.us.capcut.com/"
    }
  });

  return response;
}
```

### 智能时区选择

```javascript
function getTimezoneForRegion(region) {
  const timezoneMap = {
    'cn': 'Asia/Shanghai',
    'us': 'America/New_York',
    'jp': 'Asia/Tokyo',
    'kr': 'Asia/Seoul',
    'uk': 'Europe/London',
    'fr': 'Europe/Paris',
    'de': 'Europe/Paris'
  };

  return timezoneMap[region.toLowerCase()] || 'Asia/Shanghai';
}

async function receiveCreditWithTimezone(refreshToken, region = 'cn') {
  const timezone = getTimezoneForRegion(region);

  const requestData = {
    time_zone: timezone
  };

  const response = await request("POST", "/commerce/v1/benefits/credit_receive", refreshToken, {
    data: requestData
  });

  return response;
}
```

## 响应结构

### 成功响应 (200)

```json
{
  "ret": "0",
  "errmsg": "success",
  "data": {
    "cur_total_credits": 3600,
    "receive_quota": 100,
    "received_quota": 100,
    "credit_history": {
      "receive_id": "receive_123456",
      "receive_type": "daily_bonus",
      "receive_amount": 100,
      "balance_before": 3500,
      "balance_after": 3600,
      "create_time": 1640995200000,
      "description": "每日签到奖励",
      "time_zone": "Asia/Shanghai"
    },
    "next_receive_time": 1641081600000,
    "receive_status": "success",
    "consecutive_days": 5,
    "bonus_info": {
      "base_amount": 100,
      "bonus_amount": 0,
      "total_amount": 100
    }
  }
}
```

### 响应字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| cur_total_credits | number | 接收后的总积分 |
| receive_quota | number | 可领取积分数量 |
| received_quota | number | 实际领取积分数量 |
| credit_history | object | 本次领取记录详情 |
| next_receive_time | number | 下次可领取时间戳 |
| receive_status | string | 领取状态: "success", "already_received", "not_available" |
| consecutive_days | number | 连续领取天数 |
| bonus_info | object | 奖励信息详情 |

#### credit_history 对象

| 字段名 | 类型 | 说明 |
|--------|------|------|
| receive_id | string | 领取记录ID |
| receive_type | string | 领取类型: "daily_bonus", "consecutive_bonus", "event_bonus" |
| receive_amount | number | 领取积分数量 |
| balance_before | number | 领取前积分余额 |
| balance_after | number | 领取后积分余额 |
| create_time | number | 领取时间戳 |
| description | string | 领取描述 |
| time_zone | string | 使用的时区 |

#### bonus_info 对象

| 字段名 | 类型 | 说明 |
|--------|------|------|
| base_amount | number | 基础奖励积分 |
| bonus_amount | number | 额外奖励积分 |
| total_amount | number | 总奖励积分 |

## 常见错误码

| 错误码 | 说明 | 处理建议 |
|--------|------|----------|
| 0 | 成功 | - |
| 2001 | 用户不存在 | 检查refreshToken有效性 |
| 2002 | 参数错误 | 检查时区参数格式 |
| 2003 | 今日已领取 | 明天再试 |
| 2004 | 积分不可用 | 检查活动时间 |
| 2005 | 服务繁忙 | 稍后重试 |
| 2006 | 时区错误 | 检查时区参数 |
| 2007 | 领取次数超限 | 等待重置时间 |

## 领取状态说明

| 状态值 | 说明 | 建议 |
|--------|------|------|
| success | 领取成功 | 更新积分余额 |
| already_received | 今日已领取 | 明天再试 |
| not_available | 暂时不可领取 | 检查活动状态 |
| limit_exceeded | 领取次数超限 | 等待重置 |
| time_zone_invalid | 时区无效 | 使用默认时区 |

## 使用场景

### 1. 生成前自动领取

```javascript
async function ensureCreditForGeneration(refreshToken, requiredCredit) {
  try {
    // 查询当前积分
    const creditInfo = await getCreditInfo(refreshToken);
    const currentCredit = creditInfo.credit.total_credit;

    console.log(`当前积分: ${currentCredit}, 需要: ${requiredCredit}`);

    if (currentCredit >= requiredCredit) {
      return { sufficient: true, credit: currentCredit };
    }

    // 检查是否可以领取每日积分
    if (creditInfo.credit.benefit_status.can_receive_daily) {
      console.log('积分不足，尝试领取每日积分');

      try {
        const receiveResult = await receiveCredit(refreshToken);
        const newCredit = receiveResult.cur_total_credits;

        console.log(`领取成功，新积分: ${newCredit}`);

        return {
          sufficient: newCredit >= requiredCredit,
          credit: newCredit,
          received: receiveResult.received_quota
        };
      } catch (receiveError) {
        console.error('领取积分失败:', receiveError.message);
        return { sufficient: false, credit: currentCredit, error: receiveError };
      }
    } else {
      console.log('今日积分已领取或不可领取');
      return { sufficient: false, credit: currentCredit, reason: 'already_received' };
    }
  } catch (error) {
    console.error('积分检查失败:', error.message);
    return { sufficient: false, credit: 0, error: error };
  }
}
```

### 2. 智能领取管理

```javascript
class DailyCreditManager {
  constructor(refreshToken, region = 'cn') {
    this.refreshToken = refreshToken;
    this.region = region;
    this.lastReceiveTime = 0;
    this.receiveHistory = [];
  }

  async checkAndReceive() {
    try {
      // 检查是否今天已领取
      const today = new Date().toDateString();
      const lastReceiveDate = new Date(this.lastReceiveTime).toDateString();

      if (today === lastReceiveDate) {
        console.log('今日已领取积分');
        return { received: false, reason: 'already_received_today' };
      }

      // 查询积分状态
      const creditInfo = await getCreditInfo(this.refreshToken);

      if (!creditInfo.credit.benefit_status.can_receive_daily) {
        console.log('当前不可领取积分');
        return { received: false, reason: 'not_available' };
      }

      // 领取积分
      const receiveResult = await receiveCreditWithTimezone(
        this.refreshToken,
        this.region
      );

      // 更新状态
      this.lastReceiveTime = Date.now();
      this.receiveHistory.push({
        time: Date.now(),
        amount: receiveResult.received_quota,
        balance: receiveResult.cur_total_credits
      });

      console.log(`成功领取 ${receiveResult.received_quota} 积分`);

      return {
        received: true,
        amount: receiveResult.received_quota,
        balance: receiveResult.cur_total_credits,
        consecutiveDays: receiveResult.consecutive_days
      };

    } catch (error) {
      console.error('自动领取积分失败:', error.message);
      return { received: false, error: error };
    }
  }

  getReceiveStats() {
    const today = new Date().toDateString();
    const todayReceive = this.receiveHistory.find(
      record => new Date(record.time).toDateString() === today
    );

    return {
      lastReceiveTime: this.lastReceiveTime,
      todayReceived: !!todayReceive,
      todayAmount: todayReceive?.amount || 0,
      totalReceives: this.receiveHistory.length,
      recentReceives: this.receiveHistory.slice(-7) // 最近7次
    };
  }
}
```

### 3. 连续领取奖励追踪

```javascript
class ConsecutiveBonusTracker {
  constructor() {
    this.consecutiveDays = 0;
    this.lastReceiveDate = null;
    this.bonusSchedule = {
      1: { base: 100, bonus: 0 },
      3: { base: 100, bonus: 20 },
      7: { base: 100, bonus: 50 },
      14: { base: 100, bonus: 100 },
      30: { base: 100, bonus: 200 }
    };
  }

  updateConsecutiveDays(receiveDate) {
    const today = new Date(receiveDate);
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    if (this.lastReceiveDate) {
      const lastDate = new Date(this.lastReceiveDate);
      const daysDiff = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));

      if (daysDiff === 1) {
        // 连续领取
        this.consecutiveDays++;
      } else if (daysDiff > 1) {
        // 中断了连续领取
        this.consecutiveDays = 1;
      }
      // daysDiff === 0 表示今天已领取过
    } else {
      // 首次领取
      this.consecutiveDays = 1;
    }

    this.lastReceiveDate = receiveDate;
    return this.consecutiveDays;
  }

  calculateExpectedBonus(consecutiveDays) {
    let totalBonus = 0;
    let baseAmount = 100;

    // 计算符合条件的所有奖励
    Object.entries(this.bonusSchedule).forEach(([days, config]) => {
      if (consecutiveDays >= parseInt(days)) {
        baseAmount = config.base;
        totalBonus += config.bonus;
      }
    });

    return {
      base: baseAmount,
      bonus: totalBonus,
      total: baseAmount + totalBonus
    };
  }

  getNextMilestone(currentDays) {
    const milestones = Object.keys(this.bonusSchedule)
      .map(Number)
      .sort((a, b) => a - b);

    for (const milestone of milestones) {
      if (currentDays < milestone) {
        const daysToMilestone = milestone - currentDays;
        const reward = this.calculateExpectedBonus(milestone);
        return {
          milestone,
          daysToMilestone,
          reward: reward.total
        };
      }
    }

    return null; // 已达到所有里程碑
  }
}
```

## 地区差异

### 即梦中国

- **基础URL**: `https://jimeng.jianying.com`
- **时区**: "Asia/Shanghai"
- **每日奖励**: 100积分
- **连续奖励**: 支持连续领取额外奖励

### 即梦国际

- **基础URL**: `https://commerce.us.capcut.com`
- **时区**: "America/New_York" 或用户所在时区
- **每日奖励**: 可能不同
- **连续奖励**: 遵循国际版规则

## 性能优化

### 缓存领取状态

```javascript
const receiveStatusCache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5分钟缓存

function getCachedReceiveStatus(refreshToken) {
  const cacheKey = refreshToken;
  const cached = receiveStatusCache.get(cacheKey);

  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.status;
  }

  return null;
}

function setCachedReceiveStatus(refreshToken, status) {
  const cacheKey = refreshToken;
  receiveStatusCache.set(cacheKey, {
    status: status,
    timestamp: Date.now()
  });

  // 清理过期缓存
  setTimeout(() => {
    const cached = receiveStatusCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp >= CACHE_TTL) {
      receiveStatusCache.delete(cacheKey);
    }
  }, CACHE_TTL);
}
```

### 批量领取管理

```javascript
class BatchCreditReceiver {
  constructor(maxConcurrency = 3) {
    this.maxConcurrency = maxConcurrency;
    this.queue = [];
    this.processing = 0;
  }

  async addReceiveRequest(refreshToken, region = 'cn') {
    return new Promise((resolve, reject) => {
      this.queue.push({
        refreshToken,
        region,
        resolve,
        reject,
        timestamp: Date.now()
      });

      this.processQueue();
    });
  }

  async processQueue() {
    if (this.processing >= this.maxConcurrency || this.queue.length === 0) {
      return;
    }

    this.processing++;
    const request = this.queue.shift();

    try {
      const result = await receiveCreditWithTimezone(
        request.refreshToken,
        request.region
      );

      request.resolve(result);
    } catch (error) {
      request.reject(error);
    } finally {
      this.processing--;
      this.processQueue();
    }
  }
}
```

## 监控和日志

### 领取指标监控

```javascript
const receiveMetrics = {
  totalAttempts: 0,
  successfulReceives: 0,
  failedReceives: 0,
  duplicateReceives: 0,
  totalCreditsReceived: 0,
  avgResponseTime: 0,
  receiveByHour: {},
  receiveByRegion: {}
};

function recordReceiveAttempt(success, amount = 0, responseTime = 0, region = 'cn') {
  receiveMetrics.totalAttempts++;

  const hour = new Date().getHours();
  receiveMetrics.receiveByHour[hour] = (receiveMetrics.receiveByHour[hour] || 0) + 1;
  receiveMetrics.receiveByRegion[region] = (receiveMetrics.receiveByRegion[region] || 0) + 1;

  if (success) {
    receiveMetrics.successfulReceives++;
    receiveMetrics.totalCreditsReceived += amount;
  } else {
    receiveMetrics.failedReceives++;
  }

  const totalProcessed = receiveMetrics.successfulReceives + receiveMetrics.failedReceives;
  receiveMetrics.avgResponseTime =
    (receiveMetrics.avgResponseTime * (totalProcessed - 1) + responseTime) / totalProcessed;
}
```

### 日志记录

```javascript
function logCreditReceive(refreshToken, result, responseTime) {
  console.log('积分领取完成:', {
    tokenHash: refreshToken.substring(0, 8) + '***',
    status: result.receive_status,
    amount: result.received_quota,
    balance: result.cur_total_credits,
    consecutiveDays: result.consecutive_days,
    nextReceiveTime: new Date(result.next_receive_time).toLocaleString(),
    responseTime: responseTime,
    timestamp: new Date().toISOString()
  });
}
```

## 错误处理

### 智能重试机制

```javascript
async function receiveCreditWithRetry(refreshToken, maxRetries = 3, region = 'cn') {
  let lastError = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const result = await receiveCreditWithTimezone(refreshToken, region);

      // 检查是否成功
      if (result.receive_status === 'success') {
        return result;
      } else if (result.receive_status === 'already_received') {
        // 已领取过，不是错误
        return result;
      } else {
        // 其他状态，记录但继续重试
        console.log(`领取状态: ${result.receive_status}, 尝试 ${attempt}/${maxRetries}`);
      }

    } catch (error) {
      lastError = error;

      if (attempt === maxRetries) {
        break;
      }

      if (isRetryableError(error)) {
        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
        console.log(`领取积分失败，${delay}ms后重试 (尝试 ${attempt}/${maxRetries})`);
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        break;
      }
    }
  }

  throw lastError;
}

function isRetryableError(error) {
  const retryableMessages = [
    'timeout',
    'network',
    'connection',
    'service unavailable',
    'rate limit'
  ];

  const nonRetryableMessages = [
    'already_received',
    'not_available',
    'limit_exceeded'
  ];

  const errorMessage = error.message.toLowerCase();

  // 如果是不可重试的错误，直接返回false
  if (nonRetryableMessages.some(msg => errorMessage.includes(msg))) {
    return false;
  }

  // 如果是可重试的错误，返回true
  return retryableMessages.some(msg => errorMessage.includes(msg));
}
```

## 安全考虑

1. **频率限制**: 避免过于频繁的领取请求
2. **令牌保护**: 保护refreshToken安全
3. **时区验证**: 验证时区参数的合法性
4. **数据验证**: 验证响应数据的完整性
5. **异常监控**: 监控异常领取行为
6. **日志安全**: 避免在日志中记录敏感信息
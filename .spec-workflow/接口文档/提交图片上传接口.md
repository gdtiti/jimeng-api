# 提交图片上传接口文档

## 接口概述

**接口功能**: 提交确认图片上传完成，获取最终的图片URI

**请求方法**: POST
**接口路径**: `/?Action=CommitImageUpload&Version=2018-08-01`
**服务提供商**: AWS ImageX (字节跳动图片存储服务)
**内容类型**: application/json
**支持区域**: 即梦中国、即梦国际

## 请求参数

### URL参数 (Query Parameters)

| 参数名 | 类型 | 必需 | 说明 |
|--------|------|------|------|
| Action | string | 是 | 固定值: "CommitImageUpload" |
| Version | string | 是 | 固定值: "2018-08-01" |
| ServiceId | string | 是 | 服务ID，与申请上传权限时相同 |

### 请求体 (Request Body)

```json
{
  "SessionKey": "session_key_from_apply_response"
}
```

| 参数名 | 类型 | 必需 | 说明 |
|--------|------|------|------|
| SessionKey | string | 是 | 会话密钥，从申请上传权限接口的UploadAddress.SessionKey获取 |

## 请求URL构建

### 即梦中国URL

```
https://imagex.bytedanceapi.com/?Action=CommitImageUpload&Version=2018-08-01&ServiceId={service_id}
```

### 即梦国际URL

```
https://imagex16-normal-us-ttp.capcutapi.us/?Action=CommitImageUpload&Version=2018-08-01&ServiceId={service_id}
```

## AWS签名认证

### 签名生成流程

与申请上传权限接口类似，需要生成AWS4-HMAC-SHA256签名：

1. **创建规范请求**
   - HTTP方法: POST
   - 规范URI: /
   - 规范查询字符串: URL参数按字母顺序排列
   - 规范头部: 包含x-amz-date, x-amz-security-token, x-amz-content-sha256
   - 已签名头部: 包含的头部名称列表
   - 请求载荷哈希: 请求体的SHA256哈希

2. **创建待签名字符串**
   - 算法: AWS4-HMAC-SHA256
   - 请求日期时间: ISO格式时间戳
   - 凭证范围: date/region/service/aws4_request
   - 规范请求哈希: 规范请求的SHA256哈希

3. **计算签名**
   - 派生密钥: AWS4 -> 日期 -> 区域 -> 服务 -> 签名
   - HMAC-SHA256计算最终签名

### 请求体哈希计算

```javascript
const commitPayload = JSON.stringify({
  SessionKey: sessionKey
});

const payloadHash = crypto.createHash('sha256')
  .update(commitPayload, 'utf8')
  .digest('hex');
```

## 请求头构建

### 必需请求头

| 头部名 | 值 | 说明 |
|--------|-----|------|
| accept | "*/*" | 接受任何响应类型 |
| authorization | AWS4-HMAC-SHA256签名 | AWS签名认证 |
| content-type | "application/json" | 请求体为JSON格式 |
| origin | 域名来源 | 根据地区设置 |
| referer | 来源页面 | 根据地区设置 |
| user-agent | 浏览器标识 | Chrome浏览器标识 |
| x-amz-date | ISO格式时间戳 | 请求时间戳 |
| x-amz-security-token | 会话令牌 | 从上传令牌接口获取 |
| x-amz-content-sha256 | 载荷哈希 | 请求体的SHA256哈希 |

### 地区特定头部

| 字段名 | 即梦中国 | 即梦国际 |
|--------|----------|----------|
| origin | https://jimeng.jianying.com | https://api-proxy-1.deno.dev |
| referer | https://jimeng.jianying.com/ai-tool/generate | https://api-proxy-1.deno.dev/ai-tool/generate |

## 请求示例

### 完整请求示例

```javascript
async function commitImageUpload(serviceId, sessionKey, awsCredentials) {
  const {
    accessKeyId,
    secretAccessKey,
    sessionToken
  } = awsCredentials;

  // 构建请求URL
  const commitUrl = `https://imagex.bytedanceapi.com/?Action=CommitImageUpload&Version=2018-08-01&ServiceId=${serviceId}`;

  // 构建请求体
  const commitPayload = JSON.stringify({
    SessionKey: sessionKey
  });

  // 计算载荷哈希
  const payloadHash = crypto.createHash('sha256')
    .update(commitPayload, 'utf8')
    .digest('hex');

  // 生成时间戳
  const timestamp = new Date().toISOString()
    .replace(/[:\-]/g, '')
    .replace(/\.\d{3}Z$/, 'Z');

  // 构建请求头
  const requestHeaders = {
    'x-amz-date': timestamp,
    'x-amz-security-token': sessionToken,
    'x-amz-content-sha256': payloadHash
  };

  // 生成签名
  const authorization = createSignature(
    'POST',
    commitUrl,
    requestHeaders,
    accessKeyId,
    secretAccessKey,
    sessionToken,
    commitPayload
  );

  // 发送请求
  const response = await fetch(commitUrl, {
    method: 'POST',
    headers: {
      'accept': '*/*',
      'accept-language': 'zh-CN,zh;q=0.9',
      'authorization': authorization,
      'content-type': 'application/json',
      'origin': 'https://jimeng.jianying.com',
      'referer': 'https://jimeng.jianying.com/ai-tool/generate',
      'sec-ch-ua': '"Not A(Brand";v="8", "Chromium";v="132", "Google Chrome";v="132"',
      'sec-ch-ua-mobile': '?0',
      'sec-ch-ua-platform': '"Windows"',
      'sec-fetch-dest': 'empty',
      'sec-fetch-mode': 'cors',
      'sec-fetch-site': 'cross-site',
      'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36',
      'x-amz-date': timestamp,
      'x-amz-security-token': sessionToken,
      'x-amz-content-sha256': payloadHash,
    },
    body: commitPayload
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`提交上传失败: ${response.status} - ${errorText}`);
  }

  return await response.json();
}
```

## 响应结构

### 成功响应 (200)

```json
{
  "Result": {
    "Results": [
      {
        "Uri": "tos-cn-i-0000/1234567890abcdef",
        "UriStatus": 2000,
        "FileSize": 1024000,
        "ETag": "\"etag_string\"",
        "LastModified": "2025-01-01T00:00:00.000Z"
      }
    ],
    "PluginResult": [
      {
        "ImageUri": "tos-cn-i-0000/1234567890abcdef",
        "Status": "success"
      }
    ]
  },
  "ResponseMetadata": {
    "RequestId": "request_id_string"
  }
}
```

### 响应字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| Result | object | 提交结果信息 |
| Results | array | 上传结果列表 |
| Uri | string | 图片URI，用于后续AIGC生成 |
| UriStatus | number | URI状态码，2000表示成功 |
| FileSize | number | 文件大小（字节） |
| ETag | string | 文件ETag标识 |
| LastModified | string | 最后修改时间 |
| PluginResult | array | 插件处理结果 |
| ImageUri | string | 图片URI（与Uri相同） |
| Status | string | 处理状态 |
| ResponseMetadata | object | 响应元数据 |
| RequestId | string | 请求ID |

### URI状态码说明

| 状态码 | 说明 |
|--------|------|
| 2000 | 上传成功 |
| 2001 | 上传中 |
| 2002 | 上传失败 |
| 2003 | 文件处理中 |

### 错误响应

```json
{
  "ResponseMetadata": {
    "Error": {
      "Code": "InvalidSessionKey",
      "Message": "The provided session key is invalid or expired"
    },
    "RequestId": "request_id_string"
  }
}
```

## 常见错误码

| 错误码 | 说明 | 处理建议 |
|--------|------|----------|
| InvalidSessionKey | 会话密钥无效 | 检查SessionKey是否正确 |
| SessionNotFound | 会话不存在 | 重新申请上传权限 |
| UploadIncomplete | 上传未完成 | 确认文件已完全上传 |
| SignatureDoesNotMatch | 签名不匹配 | 检查签名计算过程 |
| AccessDenied | 访问被拒绝 | 检查权限和令牌时效性 |
| InternalServerError | 服务器内部错误 | 重试请求 |
| ServiceUnavailable | 服务不可用 | 稍后重试 |

## 使用流程

1. **获取SessionKey**: 从申请上传权限接口获取SessionKey
2. **构建请求**: 使用SessionKey和ServiceId构建提交请求
3. **生成签名**: 计算AWS4-HMAC-SHA256签名
4. **发送请求**: 提交上传确认
5. **解析响应**: 提取图片URI用于后续处理
6. **验证状态**: 确认UriStatus为2000

## 完整上传流程示例

```javascript
async function completeImageUploadFlow(imageFile, refreshToken) {
  try {
    // 步骤1: 获取上传令牌
    const tokenResult = await getUploadToken(refreshToken);

    // 步骤2: 申请上传权限
    const applyResult = await applyImageUpload(imageFile.size, tokenResult);
    const { SessionKey, UploadHosts, StoreInfos } = applyResult.UploadAddress;

    // 步骤3: 上传文件
    const uploadUrl = `https://${UploadHosts[0]}/${StoreInfos[0].StoreUri}`;
    await uploadImageFile(uploadUrl, imageFile, StoreInfos[0].Auth);

    // 步骤4: 提交上传
    const commitResult = await commitImageUpload(
      tokenResult.service_id,
      SessionKey,
      tokenResult
    );

    // 步骤5: 获取图片URI
    const imageUri = commitResult.Result.Results[0].Uri;

    console.log('图片上传完成:', imageUri);
    return imageUri;

  } catch (error) {
    console.error('图片上传流程失败:', error);
    throw error;
  }
}
```

## 错误处理最佳实践

### 重试机制

```javascript
async function commitWithRetry(commitParams, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await commitImageUpload(commitParams);
    } catch (error) {
      if (attempt === maxRetries || !isRetryableError(error)) {
        throw error;
      }

      // 指数退避
      const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
      console.log(`提交失败，${delay}ms后重试 (尝试 ${attempt}/${maxRetries})`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

function isRetryableError(error) {
  const retryableCodes = [
    'InternalServerError',
    'ServiceUnavailable',
    'RequestTimeout',
    'Throttling'
  ];

  return retryableCodes.some(code => error.message.includes(code));
}
```

### 错误恢复

```javascript
async function handleCommitError(error, commitParams) {
  if (error.message.includes('InvalidSessionKey')) {
    // SessionKey过期，重新申请上传权限
    console.log('SessionKey过期，重新申请上传权限');
    const newApplyResult = await applyImageUpload(
      commitParams.fileSize,
      commitParams.awsCredentials
    );

    // 使用新的SessionKey重新提交
    return await commitImageUpload(
      commitParams.serviceId,
      newApplyResult.UploadAddress.SessionKey,
      commitParams.awsCredentials
    );
  } else {
    // 其他错误直接抛出
    throw error;
  }
}
```

## 性能优化

### 并发提交

```javascript
async function batchCommit(commitRequests, concurrency = 5) {
  const results = [];
  const batches = [];

  // 分批处理
  for (let i = 0; i < commitRequests.length; i += concurrency) {
    batches.push(commitRequests.slice(i, i + concurrency));
  }

  // 并发执行
  for (const batch of batches) {
    const batchResults = await Promise.allSettled(
      batch.map(request => commitImageUpload(request))
    );

    results.push(...batchResults);
  }

  return results;
}
```

### 缓存优化

```javascript
const commitCache = new Map();

async function cachedCommit(commitParams) {
  const cacheKey = `${commitParams.serviceId}-${commitParams.sessionKey}`;

  if (commitCache.has(cacheKey)) {
    return commitCache.get(cacheKey);
  }

  const result = await commitImageUpload(commitParams);

  // 缓存结果，设置5分钟过期
  commitCache.set(cacheKey, result);
  setTimeout(() => commitCache.delete(cacheKey), 5 * 60 * 1000);

  return result;
}
```

## 监控和日志

### 关键指标

```javascript
const commitMetrics = {
  startTime: Date.now(),
  successCount: 0,
  errorCount: 0,
  avgResponseTime: 0
};

// 记录提交结果
function recordCommitResult(success, responseTime) {
  if (success) {
    commitMetrics.successCount++;
  } else {
    commitMetrics.errorCount++;
  }

  const totalRequests = commitMetrics.successCount + commitMetrics.errorCount;
  commitMetrics.avgResponseTime =
    (commitMetrics.avgResponseTime * (totalRequests - 1) + responseTime) / totalRequests;
}
```

### 日志记录

```javascript
console.log('提交图片上传:', {
  serviceId: serviceId,
  sessionKey: sessionKey.substring(0, 8) + '***',
  timestamp: new Date().toISOString()
});

console.log('提交上传完成:', {
  imageUri: imageUri,
  uriStatus: uriStatus,
  duration: Date.now() - startTime
});
```

## 安全考虑

1. **令牌安全**: 保护AWS凭证不被泄露
2. **数据完整性**: 验证上传文件的完整性
3. **时效性**: 检查SessionKey和凭证的有效期
4. **访问控制**: 确保用户有权限上传到指定位置
5. **HTTPS传输**: 使用HTTPS加密传输敏感数据
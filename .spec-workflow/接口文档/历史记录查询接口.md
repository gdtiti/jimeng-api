# 历史记录查询接口文档

## 接口概述

**接口功能**: 查询AIGC生成任务的历史记录，获取生成结果和状态信息

**请求方法**: POST
**接口路径**: `/mweb/v1/get_history_by_ids`
**支持区域**: 即梦中国、即梦国际
**支持查询**: 图片生成、视频生成、图生图等任务的生成状态

## 请求参数

### URL参数 (Query Parameters)

#### 通用参数

| 参数名 | 类型 | 必需 | 默认值 | 说明 |
|--------|------|------|--------|------|
| aid | string | 是 | - | 应用ID |
| device_platform | string | 是 | "web" | 设备平台 |
| region | string | 是 | - | 区域: "cn" 或 "US" |
| webId | string | 是 | - | Web ID |
| da_version | string | 是 | "3.3.2" | DA版本号 |
| web_version | string | 是 | "7.5.0" | Web版本号 |
| aigc_features | string | 是 | "app_lip_sync" | AIGC功能标识 |
| web_component_open_flag | number | 是 | 1 | Web组件开启标志 |

### 请求体 (Request Body)

#### 基础查询结构

```json
{
  "history_ids": ["history_id_1", "history_id_2"],
  "image_info": {
    "width": 2048,
    "height": 2048,
    "format": "webp",
    "image_scene_list": [
      {
        "scene": "smart_crop",
        "width": 360,
        "height": 360,
        "uniq_key": "smart_crop-w:360-h:360",
        "format": "webp"
      }
    ]
  }
}
```

#### 请求参数说明

| 参数名 | 类型 | 必需 | 说明 |
|--------|------|------|------|
| history_ids | array | 是 | 历史记录ID列表 |
| image_info | object | 否 | 图片信息配置 |
| image_info.width | number | 否 | 请求图片宽度 |
| image_info.height | number | 否 | 请求图片高度 |
| image_info.format | string | 否 | 图片格式，如"webp" |
| image_info.image_scene_list | array | 否 | 图片场景列表 |

#### 图片场景配置

| 场景名 | 说明 | 典型用途 |
|--------|------|----------|
| smart_crop | 智能裁剪 | 缩略图生成 |
| normal | 普通模式 | 标准尺寸图片 |
| high_quality | 高质量 | 高清图片 |

## 请求示例

### 基础查询请求

```javascript
async function getHistoryByIds(historyIds, refreshToken) {
  const requestData = {
    history_ids: Array.isArray(historyIds) ? historyIds : [historyIds],
    image_info: {
      width: 2048,
      height: 2048,
      format: "webp",
      image_scene_list: [
        { scene: "smart_crop", width: 360, height: 360, uniq_key: "smart_crop-w:360-h:360", format: "webp" },
        { scene: "smart_crop", width: 480, height: 480, uniq_key: "smart_crop-w:480-h:480", format: "webp" },
        { scene: "smart_crop", width: 720, height: 720, uniq_key: "smart_crop-w:720-h:720", format: "webp" },
        { scene: "smart_crop", width: 720, height: 480, uniq_key: "smart_crop-w:720-h:480", format: "webp" },
        { scene: "normal", width: 2400, height: 2400, uniq_key: "2400", format: "webp" },
        { scene: "normal", width: 1080, height: 1080, uniq_key: "1080", format: "webp" },
        { scene: "normal", width: 720, height: 720, uniq_key: "720", format: "webp" },
        { scene: "normal", width: 480, height: 480, uniq_key: "480", format: "webp" },
        { scene: "normal", width: 360, height: 360, uniq_key: "360", format: "webp" }
      ]
    }
  };

  const response = await request("POST", "/mweb/v1/get_history_by_ids", refreshToken, {
    data: requestData
  });

  return response;
}
```

### 视频查询请求

```javascript
async function getVideoHistory(historyIds, refreshToken) {
  const requestData = {
    history_ids: Array.isArray(historyIds) ? historyIds : [historyIds]
    // 视频查询通常不需要image_info参数
  };

  const response = await request("POST", "/mweb/v1/get_history_by_ids", refreshToken, {
    data: requestData
  });

  return response;
}
```

### 批量查询请求

```javascript
async function batchGetHistory(historyIds, refreshToken) {
  const batchSize = 10; // 每批最多查询10个ID
  const results = {};

  for (let i = 0; i < historyIds.length; i += batchSize) {
    const batch = historyIds.slice(i, i + batchSize);
    const batchResult = await getHistoryByIds(batch, refreshToken);

    Object.assign(results, batchResult);

    // 避免请求过于频繁
    if (i + batchSize < historyIds.length) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  return results;
}
```

## 响应结构

### 成功响应 (200)

```json
{
  "ret": "0",
  "errmsg": "success",
  "data": {
    "history_id_1": {
      "id": "history_id_1",
      "status": 10,
      "fail_code": null,
      "item_list": [
        {
          "id": "item_id",
          "image": {
            "large_images": [
              {
                "image_url": "https://example.com/image1.jpg",
                "width": 2048,
                "height": 2048,
                "format": "jpg"
              }
            ],
            "medium_images": [
              {
                "image_url": "https://example.com/image1_medium.jpg",
                "width": 720,
                "height": 720,
                "format": "jpg"
              }
            ],
            "small_images": [
              {
                "image_url": "https://example.com/image1_small.jpg",
                "width": 360,
                "height": 360,
                "format": "jpg"
              }
            ]
          },
          "common_attr": {
            "cover_url": "https://example.com/cover.jpg",
            "title": "生成的图片",
            "description": "描述信息"
          },
          "task": {
            "finish_time": 1640995200000,
            "create_time": 1640991600000,
            "cost": 100
          }
        }
      ],
      "task": {
        "finish_time": 1640995200000,
        "create_time": 1640991600000,
        "model": "high_aes_general_v40",
        "prompt": "生成提示词"
      },
      "history_group_key_md5": "group_key_md5"
    }
  }
}
```

### 视频生成响应结构

```json
{
  "ret": "0",
  "errmsg": "success",
  "data": {
    "history_id_1": {
      "id": "history_id_1",
      "status": 10,
      "fail_code": null,
      "item_list": [
        {
          "id": "item_id",
          "video": {
            "transcoded_video": {
              "origin": {
                "video_url": "https://v1-artist.vlabvod.com/video.mp4",
                "width": 1024,
                "height": 1024,
                "duration": 5000,
                "format": "mp4"
              },
              "medium": {
                "video_url": "https://v1-artist.vlabvod.com/video_medium.mp4",
                "width": 720,
                "height": 720,
                "duration": 5000,
                "format": "mp4"
              }
            },
            "play_url": "https://v1-artist.vlabvod.com/video.mp4",
            "download_url": "https://v1-artist.vlabvod.com/download.mp4",
            "thumbnail_url": "https://v1-artist.vlabvod.com/thumbnail.jpg"
          },
          "task": {
            "finish_time": 1640995200000,
            "create_time": 1640991600000,
            "cost": 200
          }
        }
      ]
    }
  }
}
```

### 响应字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| ret | string | 返回码，"0"表示成功 |
| errmsg | string | 错误信息 |
| data | object | 历史记录数据 |
| history_id | object | 对应历史ID的记录 |
| id | string | 历史记录ID |
| status | number | 状态码 |
| fail_code | string | 失败错误码 |
| item_list | array | 生成结果列表 |
| image | object | 图片信息 |
| video | object | 视频信息 |
| common_attr | object | 通用属性 |
| task | object | 任务信息 |
| history_group_key_md5 | string | 历史组密钥MD5 |

## 状态码说明

| 状态码 | 说明 | 处理建议 |
|--------|------|----------|
| 20 | 处理中 | 继续轮询查询 |
| 10 | 成功 | 提取生成结果 |
| 30 | 失败 | 检查fail_code获取错误原因 |
| 42 | 后处理中 | 等待后处理完成 |
| 45 | 完成中 | 等待最终完成 |
| 50 | 已完成 | 获取最终结果 |

## 常见错误码

| 错误码 | 说明 | 处理建议 |
|--------|------|----------|
| 2001 | 历史记录不存在 | 检查history_id是否正确 |
| 2002 | 参数错误 | 检查请求参数格式 |
| 2003 | 服务繁忙 | 稍后重试 |
| 2004 | 权限不足 | 检查用户权限 |
| 2038 | 内容被过滤 | 检查生成内容是否违规 |
| 2039 | 生成超时 | 重新生成或联系客服 |
| 2040 | 资源不足 | 检查用户积分状态 |

## 轮询策略

### 智能轮询器

```javascript
class SmartPoller {
  constructor(options = {}) {
    this.maxPollCount = options.maxPollCount || 900;
    this.expectedItemCount = options.expectedItemCount || 4;
    this.type = options.type || 'image';
    this.pollCount = 0;
    this.stableRounds = 0;
    this.lastItemCount = 0;
  }

  async poll(pollingFunction, historyId) {
    const startTime = Date.now();
    let currentStatus = { status: 20, itemCount: 0 };

    while (this.pollCount < this.maxPollCount) {
      this.pollCount++;

      try {
        const { status, data } = await pollingFunction();

        // 更新状态
        currentStatus = status;
        const itemCount = status.itemCount || 0;

        // 检查是否稳定
        if (itemCount === this.lastItemCount && itemCount > 0) {
          this.stableRounds++;
        } else {
          this.stableRounds = 0;
          this.lastItemCount = itemCount;
        }

        // 如果状态完成且数量稳定，认为完成
        if (status.status === 10 &&
            itemCount >= this.expectedItemCount &&
            this.stableRounds >= 3) {
          break;
        }

        // 如果失败，停止轮询
        if (status.status === 30) {
          break;
        }

        // 计算等待时间
        let waitTime = this.calculateWaitTime(status.status, this.pollCount);

        console.log(`轮询进度: ${this.pollCount}/${this.maxPollCount}, 状态: ${status.status}, 项目数: ${itemCount}`);

        await new Promise(resolve => setTimeout(resolve, waitTime));

      } catch (error) {
        console.error(`轮询出错: ${error.message}`);
        if (this.pollCount >= this.maxPollCount) {
          throw error;
        }
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }

    const elapsedTime = (Date.now() - startTime) / 1000;

    return {
      result: {
        status: currentStatus.status,
        pollCount: this.pollCount,
        elapsedTime: elapsedTime,
        isTimeout: this.pollCount >= this.maxPollCount
      },
      data: currentStatus.data
    };
  }

  calculateWaitTime(status, pollCount) {
    if (status === 20) {
      // 处理中状态，随轮询次数增加等待时间
      return Math.min(2000 * Math.min(pollCount, 5), 10000);
    } else if (status === 42 || status === 45) {
      // 后处理状态，较短等待时间
      return 3000;
    } else {
      // 其他状态
      return 2000;
    }
  }
}
```

### 轮询使用示例

```javascript
async function pollGenerationResult(historyId, refreshToken, type = 'image') {
  const poller = new SmartPoller({
    maxPollCount: 900,
    expectedItemCount: type === 'video' ? 1 : 4,
    type: type
  });

  const { result: pollingResult, data: finalTaskInfo } = await poller.poll(
    async () => {
      const response = await getHistoryByIds([historyId], refreshToken);

      if (!response[historyId]) {
        throw new Error('历史记录不存在');
      }

      const taskInfo = response[historyId];
      const currentStatus = taskInfo.status;
      const currentFailCode = taskInfo.fail_code;
      const currentItemList = taskInfo.item_list || [];

      return {
        status: {
          status: currentStatus,
          failCode: currentFailCode,
          itemCount: currentItemList.length,
          historyId: historyId
        },
        data: taskInfo
      };
    },
    historyId
  );

  if (pollingResult.isTimeout) {
    throw new Error('轮询超时，请稍后查看结果');
  }

  return finalTaskInfo;
}
```

## 结果提取

### 图片结果提取

```javascript
function extractImageUrls(historyData) {
  const item_list = historyData.item_list || [];

  return item_list.map((item, index) => {
    let imageUrl = null;

    // 优先使用大图
    if (item?.image?.large_images?.[0]?.image_url) {
      imageUrl = item.image.large_images[0].image_url;
    }
    // 备用封面图
    else if (item?.common_attr?.cover_url) {
      imageUrl = item.common_attr.cover_url;
    }
    // 直接图片URL
    else if (item?.image_url) {
      imageUrl = item.image_url;
    }
    // 通用URL
    else if (item?.url) {
      imageUrl = item.url;
    }

    return {
      index: index,
      url: imageUrl,
      metadata: {
        width: item?.image?.large_images?.[0]?.width,
        height: item?.image?.large_images?.[0]?.height,
        format: item?.image?.large_images?.[0]?.format
      }
    };
  }).filter(item => item.url !== null);
}
```

### 视频结果提取

```javascript
function extractVideoUrls(historyData) {
  const item_list = historyData.item_list || [];
  const videos = [];

  for (const item of item_list) {
    if (item?.video) {
      const video = item.video;

      // 提取不同质量的视频URL
      const urls = {
        origin: video.transcoded_video?.origin?.video_url,
        medium: video.transcoded_video?.medium?.video_url,
        play: video.play_url,
        download: video.download_url
      };

      // 选择最佳URL
      const bestUrl = urls.origin || urls.medium || urls.play || urls.download;

      if (bestUrl) {
        videos.push({
          url: bestUrl,
          thumbnail: video.thumbnail_url,
          metadata: {
            width: video.transcoded_video?.origin?.width,
            height: video.transcoded_video?.origin?.height,
            duration: video.transcoded_video?.origin?.duration,
            format: video.transcoded_video?.origin?.format
          },
          allUrls: urls
        });
      }
    }
  }

  return videos;
}
```

## 性能优化

### 批量查询优化

```javascript
class HistoryQueryOptimizer {
  constructor() {
    this.queryCache = new Map();
    this.pendingQueries = new Map();
  }

  async batchQuery(historyIds, refreshToken) {
    const results = {};
    const uncachedIds = [];

    // 检查缓存
    for (const id of historyIds) {
      if (this.queryCache.has(id)) {
        results[id] = this.queryCache.get(id);
      } else {
        uncachedIds.push(id);
      }
    }

    // 批量查询未缓存的ID
    if (uncachedIds.length > 0) {
      const batchResults = await this.performBatchQuery(uncachedIds, refreshToken);

      // 更新缓存和结果
      for (const [id, data] of Object.entries(batchResults)) {
        this.queryCache.set(id, data);
        results[id] = data;
      }
    }

    return results;
  }

  async performBatchQuery(historyIds, refreshToken) {
    const batchSize = 10;
    const results = {};

    for (let i = 0; i < historyIds.length; i += batchSize) {
      const batch = historyIds.slice(i, i + batchSize);
      const batchResult = await getHistoryByIds(batch, refreshToken);
      Object.assign(results, batchResult);

      // 避免请求过频
      if (i + batchSize < historyIds.length) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }

    return results;
  }
}
```

### 缓存策略

```javascript
const historyCache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5分钟

function getCachedHistory(historyId) {
  const cached = historyCache.get(historyId);

  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }

  return null;
}

function setCachedHistory(historyId, data) {
  historyCache.set(historyId, {
    data: data,
    timestamp: Date.now()
  });

  // 清理过期缓存
  setTimeout(() => {
    const cached = historyCache.get(historyId);
    if (cached && Date.now() - cached.timestamp >= CACHE_TTL) {
      historyCache.delete(historyId);
    }
  }, CACHE_TTL);
}
```

## 错误处理

### 错误恢复策略

```javascript
async function getHistoryWithRetry(historyId, refreshToken, maxRetries = 3) {
  let lastError = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const result = await getHistoryByIds([historyId], refreshToken);

      if (!result[historyId]) {
        throw new Error(`历史记录不存在: ${historyId}`);
      }

      return result[historyId];
    } catch (error) {
      lastError = error;

      if (attempt === maxRetries) {
        break;
      }

      // 判断是否可重试
      if (isRetryableError(error)) {
        const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
        console.log(`查询失败，${delay}ms后重试 (尝试 ${attempt}/${maxRetries})`);
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        break;
      }
    }
  }

  throw lastError;
}

function isRetryableError(error) {
  const retryableMessages = [
    'timeout',
    'network',
    'connection',
    'service unavailable',
    'rate limit'
  ];

  return retryableMessages.some(msg =>
    error.message.toLowerCase().includes(msg)
  );
}
```

## 监控和日志

### 查询指标

```javascript
const queryMetrics = {
  totalQueries: 0,
  successfulQueries: 0,
  failedQueries: 0,
  avgResponseTime: 0,
  cacheHitRate: 0
};

function recordQuery(success, responseTime, fromCache = false) {
  queryMetrics.totalQueries++;

  if (success) {
    queryMetrics.successfulQueries++;
  } else {
    queryMetrics.failedQueries++;
  }

  if (fromCache) {
    queryMetrics.cacheHitRate =
      (queryMetrics.cacheHitRate * (queryMetrics.totalQueries - 1) + 1) / queryMetrics.totalQueries;
  } else {
    queryMetrics.cacheHitRate =
      (queryMetrics.cacheHitRate * (queryMetrics.totalQueries - 1)) / queryMetrics.totalQueries;
  }

  const totalProcessed = queryMetrics.successfulQueries + queryMetrics.failedQueries;
  queryMetrics.avgResponseTime =
    (queryMetrics.avgResponseTime * (totalProcessed - 1) + responseTime) / totalProcessed;
}
```